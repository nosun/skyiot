## Protocol L: WiFi & App

	Make By: Moore Huang, nosun, wyf
	version: v1.3

###一、设计原则与目标

+ **辅助大循环**：小循环作为大循环的辅助，主要为了提高大循环的用户体验，一般情况下不作为独立使用
+ **快速高效**：收状态发指令更加快捷，提高用户体验
+ **降低云端负载**：如果手机检测到设备在内网，则发指令优先走小循环而不经过云端转发，降低云端负载
+ **双路降低丢包率**：如果手机与设备同在内网，且内网可连通外网，则通过双路控制设备和监听状态，降低丢包率

###二、协议要点

+ **UDP广播发现设备**：与设备通信的前提是知道设备在内网的IP，由于设备在内网的IP由路由动态分配，所以无法预先知道。只能采用在局域网内UDP广播的方式进行设备发现。只要WiFi模块端收到指定查询串就会立即回复模块相应信息。

+ **内网TCP长连接**：L口协议采用TCP长连接的通信方式，设备控制、上传状态、协议格式与T口相同，不做赘述，此处WiFi模块作为TCP Server，手机App作为TCP Client。

+ **长连接的维持**：若App希望通过内网实时监控设备状态，则建立TCP连接后，只需按照指定频率发送心跳包，来维持连接不被WiFi模块收回，即可实时收到设备的上传状态协议包。App退出实时监控状态时主动断开TCP连接。

+ **长连接的回收**：由于WiFi模块的TCP连接数有限，需要定期清理长连接。清理的规则是判断15s之内是否有收到App的有效数据（包括查询、命令、状态回复以及心跳），如果15s内没有收到任何数据则回收TCP长连接（WiFi模块主动发起TCP连接关闭）。详见  `协议内容 -> 7.查询TCP连接数` 一节

+ **长连接数的监听**：App在建立内网TCP长连接的时候，需要知道WiFi模块当前有效的TCP连接数，作为是否维持长连接的依据。如果连接数接近WiFi模块的最大可承受连接数，则为了WiFi模块的稳定运行，则放弃长连接采用短连接或走大循环。


+ **双信道上报**：设备MCU的所有状态上报数据都将同时发送到服务器（T口）和内网（L口），手机App可以使用根据sn过滤掉后到的重复数据包(两条通道的sn号相同，便于判断不同通道的相同数据包，避免误决策)

+ **AP模式与AP配网**：AP模式是WiFi模块建立一个独立的AP热点，可供App直接连接而无需经由第三方路由器连接的直连模式。在AP模式下，除了WiFi本身绑定到一个固定IP上之外，其他的与正常STA模式完全相同，包括对所有协议指令的支持。AP配网则是基于AP模式对WiFi模块进行网络配置的过程，详见  `协议内容 -> 8.AP模式配网` 一节

###三、协议通用说明

+ **端口**：WiFi模块UDP广播监听端口48899，TCP监听端口8899。如有需求可商议更改。

+ **编码与格式**：同T口协议

+ **帧结束符**：同T口协议

+ **MCU编码格式**：同T口协议

+ **包sn号规则**：同T口协议

+ **名词&缩写约定**：同T口协议
 
###四、协议详细内容

#### 1. 广播发现（UDP）

App向 `48899` 端口发送 `HF-A11ASSISTHREAD` 口令的UDP广播，Wi
Fi模块收到后会返回当前模块的 IP 地址、MAC 地址信息以及WiFi模块型号，如 `192.168.1.11,ACCF231120C4,HF-LPB100`

#### 2. App登录 

**Request (App to WiFi):**

	{
	    "sn": 1020,
	    "cmd": "login",
	}

**Response (WiFi to App):**

	{
	    "sn": 1020,
	    "cmd": "login",
	    "ret": "200",
	    "mac": "AABBCCDDEEFF",
	    "pv": "1.0",
	    "sv": "<hard version | software version>",
	    "data": [
	        "pid::12345",
	        "pkey::12345",
	        "usrver::<string>"
	    ]
	}

>WiFi作为Server，App作为client，向Wifi发起连接，并发出登录请求，WiFi收到登录指令，需立刻向MCU下发`0x01` 设备查询指令，3s之内如果MCU如果不上报，返回一个错误给App，否则返回设备的基础信息。此过程App一直等待WiFi返回信息，直到WiFi成功查询状态给App，成功或者失败。
>
>**注意**：此包不能同时发给Server（T口），这样的话会导致Server端的设备重登录逻辑，造成数据混乱。

#### 3. 设备状态查询 

**Request (App to WiFi):**

	{
	    "sn": 1021,
	    "cmd": "info",
	}

**Request (WiFi to App):**

	{
	    "sn": 1021,
	    "cmd": "info",
	    "ret":200
	}

>App 与 Wifi建立连接之后，需要立刻获取设备的信息，在中间的过程中也可能会需要查询设备的所有状态信息，此时使用此接口，App下发查询指令，Wifi收到后回复200 表示收到，同时下发 `0x06` 查询指令，设备收到指令立刻上报当前所有状态，WiFi收到后上报大小循环。

#### 4. 发送心跳

**Request (App to WiFi):**

    {
        "sn": 1022,
        "cmd": "heartbeat"
    }

**Response (WiFi to App):**

    {
        "sn": 1022,
        "cmd": "heartbeat"
    }

> 此包只为在长连接时维持连接，无应答包，WiFi模块会对15s内无数据的连接进行回收，故App的心跳周期应小于此值。

#### 5. 设备控制

同T口协议

#### 6. 上传状态

同T口协议

#### 7. 查询TCP连接数

**Request (App to WiFi):**

    {
        "sn": 1023,
        "cmd": "linknum"
    }

**Response (WiFi to App):**

    {
        "sn": 1023,
        "cmd": "linknum",
		"num": "5"
    }

>一般是在TCP连接建立之后，App向WiFi模块请求当前有效的TCP连接数量。如果接近连接数上限，App会切换短连接或者走大循环。


#### 8. AP模式配网

**Request (App to WiFi-AP):**
    
	{
		"sn": 1024,
		"cmd": "config",
		"wsssid": "XXX",
		"wskey": "WPA2PSK,AES,*****"
	}
    
**Request (App to WiFi-AP):**

    {
		"sn": 1024,
		"cmd": "config",
		"ret": 200
	}

>本指令用于App通过Ap模式为wifi模块配网，大致流程如下：
>
>1. 用户通过硬件触发wifi模块开启AP模式。
2. App扫描周围是否有AP指定的SSID名称，如果扫描到则直接自动或提示用户手动切网到WiFi的AP。
3. App与WiFi模块建立连接。如果成功则将WiFi的SSID和密码通过TCP连接发送至WiFi模块。
4. WiFi收到信息，设置自身的SockA，Wmode为STA,请根据是否设置成功回复App消息。重启，之后尝试连接路由器，并回复App是否能正常连接路由器。
5. App 收到Wifi成功或失败的状态值，如果成功，则尝试向服务器请求设备的状态，反复尝试三次。如果失败则反馈给用户相应的错误消息。
6. 如果WiFi模块连接不到用户指定的WiFi，要及时**切回AP模式**或者保持AP模式。然后App等待的时间内发现此Ap后认为配置失败，提示用户重新回到步骤2.

#### 9. WiFi固件升级

同T口协议

#### 10. 错误事件

同T口协议


**超时重传机制**

同T口协议

### 五、ret 错误码

同T口协议